"""
Microring Photonic Components for PtONN-TESTS

Implementation of microring resonators and related components
for photonic neural network simulation.
""" 

import torch
import torch.nn as nn
import numpy as np
from typing import List, Tuple, Optional, Dict, Union
import math
import warnings

class MicroringResonator(nn.Module):
    """
    Microring Resonator - PAR√ÅMETROS REALISTAS v4.0
    
    ‚úÖ CAMBIOS FUNDAMENTALES v4.0:
    - Q=5,000 (no 20,000) ‚Üí resonancia visible
    - Œ∫=0.1 (no 0.017) ‚Üí ecuaciones estables  
    - Rango optimizado para UNA resonancia
    - Extinction ratio 15-20 dB realista
    """
    
    def __init__(
        self,
        radius: float = 10e-6,  # 10 Œºm radio
        coupling_strength: float = 0.1,  # ‚úÖ REALISTA y estable
        q_factor: float = 5000,  # ‚úÖ REALISTA para demos
        center_wavelength: float = 1550e-9,  # Wavelength central
        fsr: float = None,  # Free Spectral Range
        thermal_coefficient: float = 8.6e-5,  # Coef. termo-√≥ptico /K
        device: Optional[torch.device] = None
    ):
        super().__init__()
        
        if device is None:
            device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.device = device
        
        self.radius = radius
        self.q_factor = q_factor
        self.center_wavelength = center_wavelength
        self.thermal_coefficient = thermal_coefficient
        self.coupling_strength = coupling_strength
        
        # F√≠sica correcta pero par√°metros pr√°cticos
        self.n_eff = 2.4   # Effective index
        self.n_g = 4.2     # Group index
        self.circumference = 2 * np.pi * radius
        
        # FSR correcto
        if fsr is None:
            self.fsr = (center_wavelength**2) / (self.n_g * self.circumference)
            print(f"üîß FSR: {self.fsr*1e12:.1f} pm (R={radius*1e6:.1f}Œºm)")
        else:
            self.fsr = fsr
        
        # ‚úÖ PAR√ÅMETROS REALISTAS
        alpha = np.exp(-np.pi / q_factor)
        kappa_critical = np.sqrt(1 - alpha**2)
        
        print(f"   üìä Q={q_factor} (realista para demos)")
        print(f"   üìä Œ±={alpha:.6f}")
        print(f"   üìä Œ∫_critical={kappa_critical:.4f}, Œ∫={coupling_strength:.4f}")
        print(f"   üìä Extinction ratio esperado: {10*np.log10(4*q_factor*(coupling_strength**2)):.1f} dB")
        
        # Par√°metros entrenables
        self.phase_shift = nn.Parameter(torch.zeros(1, device=device))
        self.coupling_tuning = nn.Parameter(torch.tensor([coupling_strength], device=device))
        
        # Estado interno
        self.register_buffer('photon_energy', torch.zeros(1, device=device))
        self.register_buffer('temperature_shift', torch.zeros(1, device=device))
        
        # ‚úÖ GARANTIZAR resonancia visible en 1550nm exacto
        self._set_exact_resonance()
    
    def _set_exact_resonance(self):
        """Configurar resonancia exacta en center_wavelength."""
        # Calcular phase para resonancia perfecta
        target_phase = 2 * np.pi * self.n_eff * self.circumference / self.center_wavelength
        
        # Ajustar para resonancia exacta (œÜ = 2œÄm)
        resonance_order = round(target_phase / (2 * np.pi))
        exact_phase = 2 * np.pi * resonance_order
        
        # Phase shift para centrar resonancia
        self.phase_shift.data.fill_(exact_phase - target_phase)
        
        print(f"   üéØ Resonancia centrada: m={resonance_order}, œÜ_shift={self.phase_shift.item():.4f}")
    
    def get_transmission(self, wavelengths: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        ‚úÖ TRANSMISI√ìN con PAR√ÅMETROS REALISTAS v4.0
        
        Q=5000 y Œ∫=0.1 ‚Üí ecuaciones estables, resonancia visible
        """
        # Thermal shift m√≠nimo
        thermal_shift = self.temperature_shift * self.thermal_coefficient * 0.01
        
        # ‚úÖ FASE round-trip
        phase_round_trip = (2 * np.pi * self.n_eff * self.circumference / wavelengths) + self.phase_shift
        
        # ‚úÖ COUPLING realista y estable
        kappa = torch.clamp(self.coupling_tuning, 0.01, 0.99)
        t = torch.sqrt(1 - kappa**2)
        
        # ‚úÖ LOSS con Q realista
        alpha = torch.exp(torch.tensor(-np.pi / self.q_factor, device=self.device, dtype=torch.float32))
        
        # ‚úÖ ECUACIONES ESTABLES
        cos_phi = torch.cos(phase_round_trip)
        sin_phi = torch.sin(phase_round_trip)
        
        # Denominador estable (no cerca de cero)
        denom_real = 1 - alpha * t * cos_phi
        denom_imag = alpha * t * sin_phi
        denom_magnitude_sq = denom_real**2 + denom_imag**2
        
        # THROUGH PORT 
        through_real = t - alpha * cos_phi
        through_imag = alpha * sin_phi
        through_magnitude_sq = through_real**2 + through_imag**2
        through_transmission = through_magnitude_sq / denom_magnitude_sq
        
        # DROP PORT
        drop_transmission = (kappa**2 * alpha) / denom_magnitude_sq
        
        # ‚úÖ NO necesita renormalizaci√≥n con par√°metros realistas
        return through_transmission, drop_transmission
    
    def apply_nonlinear_effects(self, input_power: torch.Tensor):
        """Efectos no-lineales m√≠nimos."""
        # Efectos muy peque√±os para no perturbar
        tpa_coefficient = torch.tensor(0.8e-11, device=self.device, dtype=torch.float32)
        kerr_coefficient = torch.tensor(2.7e-18, device=self.device, dtype=torch.float32)
        
        # Updates muy peque√±os
        self.photon_energy += input_power * 0.0001
        
        # Thermal muy peque√±o
        thermal_power = tpa_coefficient * input_power**2
        self.temperature_shift += thermal_power * 1e-6
        
        # Kerr muy peque√±o
        kerr_phase = kerr_coefficient * input_power
        
        return kerr_phase
    
    def forward(self, input_signal: torch.Tensor, wavelengths: torch.Tensor) -> Dict[str, torch.Tensor]:
        """Forward pass con par√°metros realistas."""
        batch_size = input_signal.size(0)
        n_wavelengths = wavelengths.size(0)
        
        # Efectos no-lineales muy peque√±os
        input_power = torch.abs(input_signal)**2
        kerr_phase = self.apply_nonlinear_effects(input_power.mean())
        
        # Phase shift casi nulo
        self.phase_shift.data += kerr_phase * 1e-6
        
        # Calcular transmisi√≥n
        through_trans, drop_trans = self.get_transmission(wavelengths)
        
        # Aplicar
        through_output = input_signal * through_trans.unsqueeze(0)
        drop_output = input_signal * drop_trans.unsqueeze(0)
        
        return {
            'through': through_output,
            'drop': drop_output,
            'transmission_through': through_trans,
            'transmission_drop': drop_trans
        }

class AddDropMRR(nn.Module):
    """Add-Drop Microring Resonator - PAR√ÅMETROS REALISTAS v4.0"""

    def __init__(
        self,
        radius: float = 10e-6,
        coupling_strength_1: float = 0.1,  # ‚úÖ REALISTA
        coupling_strength_2: float = 0.1,  # ‚úÖ REALISTA  
        q_factor: float = 5000,  # ‚úÖ REALISTA
        center_wavelength: float = 1550e-9,
        n_eff: float = 2.4,
        n_g: float = 4.2,
        device: Optional[torch.device] = None,
        **kwargs
    ):
        super().__init__()

        if device is None:
            device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.device = device

        self.radius = radius
        self.center_wavelength = center_wavelength
        self.n_eff = n_eff
        self.q_factor = q_factor

        print(f"üîß Add-Drop MRR v4: R={radius*1e6:.1f}Œºm, Q={q_factor}")

        self.coupling_1 = nn.Parameter(torch.tensor([coupling_strength_1], device=device))
        self.coupling_2 = nn.Parameter(torch.tensor([coupling_strength_2], device=device))

        # Phase shifts
        self.phi_1 = nn.Parameter(torch.zeros(1, device=device))
        self.phi_2 = nn.Parameter(torch.zeros(1, device=device))
        self.phi_ring = nn.Parameter(torch.zeros(1, device=device))

        # Ring parameters
        self.circumference = 2 * np.pi * radius
        self.fsr = center_wavelength**2 / (n_g * self.circumference)

        # Round-trip loss
        loss_per_round_trip = 2 * np.pi / q_factor
        self.register_buffer("alpha", torch.tensor(np.exp(-loss_per_round_trip/2), device=device))

        print(f"   FSR: {self.fsr*1e12:.1f} pm")

    def get_ring_round_trip_phase(self, wavelengths: torch.Tensor) -> torch.Tensor:
        """Calcular fase de round-trip."""
        beta = 2 * np.pi * self.n_eff / wavelengths
        phi_propagation = beta * self.circumference
        phi_total = phi_propagation + self.phi_ring
        return phi_total

    def forward(
        self, 
        input_signal: torch.Tensor,
        add_signal: torch.Tensor, 
        wavelengths: torch.Tensor
    ) -> Dict[str, torch.Tensor]:
        """Forward pass con par√°metros realistas."""
        
        # Ecuaciones simplificadas y estables
        phase_rt = self.get_ring_round_trip_phase(wavelengths)
        
        kappa_1 = torch.clamp(self.coupling_1, 0.01, 0.99)
        kappa_2 = torch.clamp(self.coupling_2, 0.01, 0.99)
        
        t1 = torch.sqrt(1 - kappa_1**2)
        t2 = torch.sqrt(1 - kappa_2**2)
        
        # Transfer functions
        cos_phi = torch.cos(phase_rt)
        sin_phi = torch.sin(phase_rt)
        
        denom_real = 1 - self.alpha * t1 * t2 * cos_phi
        denom_imag = self.alpha * t1 * t2 * sin_phi
        denom_sq = denom_real**2 + denom_imag**2
        
        # Through response
        through_num_real = t1 * t2 - self.alpha * cos_phi
        through_num_imag = self.alpha * sin_phi
        through_response = (through_num_real**2 + through_num_imag**2) / denom_sq
        
        # Drop response
        drop_response = (kappa_1 * kappa_2 * self.alpha) / denom_sq
        
        # Apply to signals
        through_output = input_signal * through_response.unsqueeze(0)
        drop_output = input_signal * drop_response.unsqueeze(0) + add_signal * 0.01

        return {
            'through': through_output,
            'drop': drop_output,
            'coupling_1': self.coupling_1.detach(),
            'coupling_2': self.coupling_2.detach(), 
            'round_trip_loss': (1 - self.alpha**2).detach(),
            'fsr': self.fsr
        }

def test_basic_components():
    """Test con par√°metros realistas."""
    import torch
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    print("üß™ Testing REALISTIC microring parameters...")
    
    # Test con Q=5000, Œ∫=0.1
    mrr = MicroringResonator(device=device)
    
    # ‚úÖ RANGO REALISTA: ¬±50pm para ver UNA resonancia clara
    wavelengths = torch.linspace(1549.95e-9, 1550.05e-9, 1000, device=device)  # ¬±50pm
    input_signal = torch.ones(1, 1000, device=device)
    output = mrr(input_signal, wavelengths)
    
    # Verificar extinction ratio
    through_response = output['transmission_through']
    min_val = torch.min(through_response).item()
    max_val = torch.max(through_response).item()
    
    print(f"  üìä Through: min={min_val:.4f}, max={max_val:.4f}")
    
    if min_val > 0 and max_val > min_val:
        extinction_ratio_db = 10 * np.log10(max_val / min_val)
        print(f"  üìä Extinction ratio: {extinction_ratio_db:.1f} dB")
        
        if extinction_ratio_db > 10:
            print("  üéâ ¬°RESONANCIA VISIBLE!")
            return True
        else:
            print(f"  ‚ö†Ô∏è Extinci√≥n baja: {extinction_ratio_db:.1f} dB")
            return False
    
    return False
